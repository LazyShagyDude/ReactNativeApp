{"version":3,"sources":["useMaskedInputProps.tsx"],"names":["props","value","mask","onChangeText","placeholderFillCharacter","obfuscationCharacter","showObfuscatedValue","maskAutoComplete","maskArray","React","useMemo","formattedValueResult","text","maskHasObfuscation","find","maskItem","Array","isArray","isValueObfuscated","handleChangeText","useCallback","textToFormat","masked","length","slice","result","unmasked","obfuscated","defaultPlaceholder","map","maskChar","join","undefined","inputValue","selection","start","end","placeholder"],"mappings":"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","sourcesContent":["import * as React from 'react';\n\nimport formatWithMask from './formatWithMask';\nimport type { UseMaskedInputProps } from './useMaskedInputProps.types';\n\nexport default (props: UseMaskedInputProps) => {\n  const {\n    value,\n    mask,\n    onChangeText,\n    placeholderFillCharacter = '_',\n    obfuscationCharacter,\n    showObfuscatedValue,\n    maskAutoComplete,\n  } = props;\n\n  const maskArray = React.useMemo(\n    () => (typeof mask === 'function' ? mask(value) : mask),\n    [mask, value]\n  );\n\n  const formattedValueResult = React.useMemo(() => {\n    return formatWithMask({ text: value || '', mask, obfuscationCharacter });\n  }, [mask, obfuscationCharacter, value]);\n\n  const maskHasObfuscation = React.useMemo(\n    () => maskArray && !!maskArray.find((maskItem) => Array.isArray(maskItem)),\n    [maskArray]\n  );\n\n  const isValueObfuscated = React.useMemo(\n    () => !!maskHasObfuscation && !!showObfuscatedValue,\n    [maskHasObfuscation, showObfuscatedValue]\n  );\n\n  const handleChangeText = React.useCallback(\n    (text: string) => {\n      let textToFormat = text;\n\n      if (isValueObfuscated) {\n        textToFormat = formattedValueResult.masked || '';\n\n        if (textToFormat.length > text.length) {\n          textToFormat = textToFormat.slice(0, -1);\n        } else if (textToFormat.length < text.length) {\n          textToFormat = textToFormat + text[text.length - 1];\n        }\n      }\n\n      const result = formatWithMask({\n        text: textToFormat,\n        mask,\n        obfuscationCharacter,\n        maskAutoComplete:\n          maskAutoComplete && textToFormat.length > formattedValueResult.masked.length,\n      });\n\n      onChangeText && onChangeText(result.masked, result.unmasked, result.obfuscated);\n    },\n    [\n      isValueObfuscated,\n      mask,\n      obfuscationCharacter,\n      onChangeText,\n      formattedValueResult.masked,\n      maskAutoComplete,\n    ]\n  );\n\n  const defaultPlaceholder = React.useMemo(() => {\n    if (maskArray) {\n      return maskArray\n        .map((maskChar) => {\n          if (typeof maskChar === 'string') {\n            return maskChar;\n          } else {\n            return placeholderFillCharacter;\n          }\n        })\n        .join('');\n    } else {\n      return undefined;\n    }\n  }, [maskArray, placeholderFillCharacter]);\n\n  const inputValue = isValueObfuscated\n    ? formattedValueResult.obfuscated\n    : formattedValueResult.masked;\n\n  return {\n    onChangeText: handleChangeText,\n    value: inputValue,\n    selection: isValueObfuscated\n      ? { start: inputValue.length, end: inputValue.length }\n      : undefined,\n    placeholder: defaultPlaceholder,\n  };\n};\n"]}