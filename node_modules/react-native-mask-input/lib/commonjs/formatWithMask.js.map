{"version":3,"sources":["formatWithMask.ts"],"names":["formatWithMask","props","text","mask","obfuscationCharacter","maskAutoComplete","masked","unmasked","obfuscated","maskArray","maskCharIndex","valueCharIndex","length","maskChar","valueChar","unmaskedValueChar","shouldObsfucateChar","Array","isArray","maskCharRegex","matchRegex","RegExp","test"],"mappings":";;;;;;;AAEe,SAASA,cAAT,CACbC,KADa,EAES;AACtB,QAAM;AAAEC,IAAAA,IAAF;AAAQC,IAAAA,IAAR;AAAcC,IAAAA,oBAAoB,GAAG,GAArC;AAA0CC,IAAAA,gBAAgB,GAAG;AAA7D,MAAuEJ,KAA7E,CADsB,CAGtB;;AACA,MAAI,CAACC,IAAL,EAAW,OAAO;AAAEI,IAAAA,MAAM,EAAE,EAAV;AAAcC,IAAAA,QAAQ,EAAE,EAAxB;AAA4BC,IAAAA,UAAU,EAAE;AAAxC,GAAP;AACX,MAAI,CAACL,IAAL,EACE,OAAO;AACLG,IAAAA,MAAM,EAAEJ,IAAI,IAAI,EADX;AAELK,IAAAA,QAAQ,EAAEL,IAAI,IAAI,EAFb;AAGLM,IAAAA,UAAU,EAAEN,IAAI,IAAI;AAHf,GAAP;AAMF,MAAIO,SAAS,GAAG,OAAON,IAAP,KAAgB,UAAhB,GAA6BA,IAAI,CAACD,IAAD,CAAjC,GAA0CC,IAA1D;AAEA,MAAIG,MAAM,GAAG,EAAb;AACA,MAAIE,UAAU,GAAG,EAAjB;AACA,MAAID,QAAQ,GAAG,EAAf;AAEA,MAAIG,aAAa,GAAG,CAApB;AACA,MAAIC,cAAc,GAAG,CAArB;;AAEA,SAAO,IAAP,EAAa;AACX;AACA,QAAID,aAAa,KAAKD,SAAS,CAACG,MAAhC,EAAwC;AACtC;AACD;;AAED,QAAIC,QAAQ,GAAGJ,SAAS,CAACC,aAAD,CAAxB;AACA,QAAII,SAAS,GAAGZ,IAAI,CAACS,cAAD,CAApB,CAPW,CASX;;AACA,QAAIA,cAAc,KAAKT,IAAI,CAACU,MAA5B,EAAoC;AAClC,UAAI,OAAOC,QAAP,KAAoB,QAApB,IAAgCR,gBAApC,EAAsD;AACpDC,QAAAA,MAAM,IAAIO,QAAV;AACAL,QAAAA,UAAU,IAAIK,QAAd;AAEAH,QAAAA,aAAa,IAAI,CAAjB;AACA;AACD;;AACD;AACD,KAnBU,CAqBX;;;AACA,QAAIG,QAAQ,KAAKC,SAAjB,EAA4B;AAC1BR,MAAAA,MAAM,IAAIO,QAAV;AACAL,MAAAA,UAAU,IAAIK,QAAd;AAEAF,MAAAA,cAAc,IAAI,CAAlB;AACAD,MAAAA,aAAa,IAAI,CAAjB;AACA;AACD;;AAED,QAAIK,iBAAiB,GAAGb,IAAI,CAACS,cAAD,CAA5B,CA/BW,CAiCX;;AACA,QAAI,OAAOE,QAAP,KAAoB,QAAxB,EAAkC;AAChC;AACAF,MAAAA,cAAc,IAAI,CAAlB;AAEA,YAAMK,mBAAmB,GAAGC,KAAK,CAACC,OAAN,CAAcL,QAAd,CAA5B;AAEA,YAAMM,aAAa,GAAGF,KAAK,CAACC,OAAN,CAAcL,QAAd,IAA0BA,QAAQ,CAAC,CAAD,CAAlC,GAAwCA,QAA9D;AAEA,YAAMO,UAAU,GAAGC,MAAM,CAACF,aAAD,CAAN,CAAsBG,IAAtB,CAA2BR,SAA3B,CAAnB,CARgC,CAUhC;;AACA,UAAIM,UAAJ,EAAgB;AACdd,QAAAA,MAAM,IAAIQ,SAAV;AACAN,QAAAA,UAAU,IAAIQ,mBAAmB,GAAGZ,oBAAH,GAA0BU,SAA3D;AACAP,QAAAA,QAAQ,IAAIQ,iBAAZ;AAEAL,QAAAA,aAAa,IAAI,CAAjB;AACD;;AAED;AACD,KApBD,MAoBO;AACL;AACAJ,MAAAA,MAAM,IAAIO,QAAV;AACAL,MAAAA,UAAU,IAAIK,QAAd;AAEAH,MAAAA,aAAa,IAAI,CAAjB;AACA;AACD;AACF;;AAED,SAAO;AAAEJ,IAAAA,MAAF;AAAUC,IAAAA,QAAV;AAAoBC,IAAAA;AAApB,GAAP;AACD","sourcesContent":["import type { FormatWithMaskProps, FormatWithMaskResult } from './formatWithMask.types';\n\nexport default function formatWithMask(\n  props: FormatWithMaskProps\n): FormatWithMaskResult {\n  const { text, mask, obfuscationCharacter = '*', maskAutoComplete = false } = props;\n\n  // make sure it'll not break with null or undefined inputs\n  if (!text) return { masked: '', unmasked: '', obfuscated: '' };\n  if (!mask)\n    return {\n      masked: text || '',\n      unmasked: text || '',\n      obfuscated: text || '',\n    };\n\n  let maskArray = typeof mask === 'function' ? mask(text) : mask;\n\n  let masked = '';\n  let obfuscated = '';\n  let unmasked = '';\n\n  let maskCharIndex = 0;\n  let valueCharIndex = 0;\n\n  while (true) {\n    // if mask is ended, break.\n    if (maskCharIndex === maskArray.length) {\n      break;\n    }\n\n    let maskChar = maskArray[maskCharIndex];\n    let valueChar = text[valueCharIndex];\n\n    // if value is ended, break.\n    if (valueCharIndex === text.length) {\n      if (typeof maskChar === 'string' && maskAutoComplete) {\n        masked += maskChar;\n        obfuscated += maskChar;\n\n        maskCharIndex += 1;\n        continue;\n      }\n      break;\n    }\n\n    // value equals mask: add to masked result and advance on both mask and value indexes\n    if (maskChar === valueChar) {\n      masked += maskChar;\n      obfuscated += maskChar;\n\n      valueCharIndex += 1;\n      maskCharIndex += 1;\n      continue;\n    }\n\n    let unmaskedValueChar = text[valueCharIndex];\n\n    // it's a regex maskChar: let's advance on value index and validate the value within the regex\n    if (typeof maskChar === 'object') {\n      // advance on value index\n      valueCharIndex += 1;\n\n      const shouldObsfucateChar = Array.isArray(maskChar);\n\n      const maskCharRegex = Array.isArray(maskChar) ? maskChar[0] : maskChar;\n\n      const matchRegex = RegExp(maskCharRegex).test(valueChar);\n\n      // value match regex: add to masked and unmasked result and advance on mask index too\n      if (matchRegex) {\n        masked += valueChar;\n        obfuscated += shouldObsfucateChar ? obfuscationCharacter : valueChar;\n        unmasked += unmaskedValueChar;\n\n        maskCharIndex += 1;\n      }\n\n      continue;\n    } else {\n      // it's a fixed maskChar: add to maskedResult and advance on mask index\n      masked += maskChar;\n      obfuscated += maskChar;\n\n      maskCharIndex += 1;\n      continue;\n    }\n  }\n\n  return { masked, unmasked, obfuscated };\n}\n"]}